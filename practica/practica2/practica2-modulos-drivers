# Practica 2
## Módulos y Drivers Teoría
### 1.  ¿Cómo se denomina en GNU/Linux a la porción de código que se agrega al kernel en tiempo de ejecución? ¿Es necesario reiniciar el sistema al cargarlo?. Si no se pudiera utilizar esto. ¿Cómo deberíamos hacer para proveer la misma funcionalidad en Gnu/Linux? 
- La porción de código que se puede agregar al kernel de GNU/Linux en tiempo de ejecución se denomina módulo del kernel o LKMs (Loadable Kernel Modules). La utilidad principal es la dinamismo y flexibilidad: uno puede cargar (`insmod`, `modprobe`) o descargar (`rmmod`) un módulo en tiempo real, facilitando el mantenimiento y pruebas, y reduciendo el tiempo fuera de servicio del sistema.  
- No, no es necesario reiniciar. Esa es justamente una de las ventajas: se puede agregar funcionalidad al kernel mientras el sistema está corriendo.  
- En ese caso, toda la funcionalidad requerida debería estar compilada directamente en el kernel. Para hacerlo, se tendría que:
  - Modificar la configuración del kernel (`make menuconfig`).
  - Recompilar el kernel completo con la funcionalidad deseada.
### 2.  ¿Qué es un driver? ¿Para qué se utiliza? 
Un driver es un programa o conjunto de rutinas de bajo nivel que permite al sistema operativo comunicarse e interactuar con un dispositivo de hardware específico, también actúa como intermediario ya que traduce las instrucciones genéricas del sistema operativo en comandos específicos que el hardware puede entender, y viceversa.  
**<u>Los drivers son esenciales para:</u>**
- Detectar y administrar el hardware.
- Permitir que las aplicaciones usen dispositivos sin preocuparse por los detalles técnicos del hardware.
- Garantizar la portabilidad: el mismo sistema puede funcionar con distintos dispositivos si tiene el driver correspondiente.
### 3.  ¿Por qué es necesario escribir drivers? 
**Diversidad de Hardware:** Sin un driver, el sistema operativo no podría interactuar con ellos de manera estándar, ya que cada dispositivo tiene un comportamiento único que debe ser gestionado de forma especializada.

**Abstracción:** Los drivers proporcionan una capa de abstracción entre el hardware y el sistema operativo. Sin esta abstracción, cada programa tendría que "saber" cómo comunicarse directamente con cada dispositivo.

**Portabilidad**: Los drivers permiten que el sistema operativo sea más portátil. Sin ellos, el sistema operativo debería estar diseñado específicamente para cada dispositivo.

**Optimización y Control:** Los drivers también son necesarios para optimizar el uso del hardware, aprovechando al máximo sus capacidades y controlando aspectos específicos del mismo, como el manejo de la memoria, la gestión de energía o la sincronización de operaciones.

**Actualización y Flexibilidad:** Los drivers pueden actualizarse sin necesidad de cambiar el núcleo del sistema operativo, permitiendo mejoras en el rendimiento, corrección de errores o soporte de nuevos dispositivos sin afectar a la estabilidad global del sistema.
### 4.  ¿Cuál es la relación entre módulo y driver en GNU/Linux? 
- Un driver es un programa que **permite al sistema usar hardware.**
- Un módulo es una **pieza de código que se puede agregar al kernel en tiempo de ejecución.**
- **En GNU/Linux, muchos drivers están implementados como módulos del kernel**, por lo que un driver suele ser un tipo de módulo.
### 5.  ¿Qué implicancias puede tener un bug en un driver o módulo? 
**Caída del sistema (kernel panic):**
Un error grave puede provocar un kernel panic, una situación en la que el sistema operativo detecta un fallo irrecuperable y se detiene completamente para evitar dañar los datos o el hardware.

**Corrupción de memoria:** Como el módulo tiene acceso sin restricciones a la memoria del sistema, un puntero mal manejado puede sobrescribir regiones críticas de memoria, afectando el funcionamiento del sistema o corrompiendo datos.

**Fallas intermitentes o impredecibles:** Algunos bugs no causan un fallo inmediato, sino comportamientos erráticos: pérdidas de conectividad, errores de lectura/escritura, mal funcionamiento de dispositivos, etc.

**Vulnerabilidades de seguridad:** Un bug puede ser explotado por un atacante para ejecutar código arbitrario en modo kernel, lo que le daría control total del sistema, con consecuencias potenciales como robo de datos, instalación de rootkits, etc.

### 6.  ¿Qué tipos de drivers existen en GNU/Linux? 
Los drivers se pueden clasificar según el **tipo de hardware o funcionalidad que manejan.**:

1. **Drivers de dispositivos de carácter**  
Permiten el acceso secuencial o por flujo, como si fuera un archivo.  
**Ejemplos:** terminales, puertos serie, dispositivos de audio.  
Se accede a través de archivos en `/dev` como `/dev/ttyS0`.  

2. **Drivers de dispositivos de bloque**  
Acceden al hardware en bloques de datos (como sectores de disco). Se utilizan para almacenamiento.  
**Ejemplos:** discos duros, unidades SSD, memorias USB.  
Se accede a través de archivos como `/dev/sda`, `/dev/nvme0n1`.  

3. **Drivers de red (network drivers)**  
Gestionan interfaces de red y protocolos.  
**Ejemplos:** controladores de tarjetas de red Ethernet o Wi-Fi.  
Aparecen como interfaces como `eth0`, `wlan0`.  

4. **Drivers de sistema de archivos (filesystem drivers)**  
Permiten al kernel entender diferentes formatos de sistemas de archivos.  
**Ejemplos:** `ext4`, `btrfs`, `ntfs`.  
Pueden ser integrados en el kernel o cargados como módulos.  

5. **Drivers de dispositivos gráficos**  
Controlan placas de video (GPU).  
Pueden ser libres (como nouveau para NVIDIA) o propietarios (como los drivers oficiales de NVIDIA o AMD).  
Impactan directamente en el rendimiento gráfico, soporte de aceleración, etc.  

6. **Drivers virtuales o pseudo-dispositivos**  
No representan hardware físico, sino interfaces virtuales.   
**Ejemplos:** `/dev/null`, `/dev/random`, `loop devices`.  

7. **Drivers de dispositivos de entrada**  
Gestionan teclado, mouse, touchpad, etc.  
Se conectan al subsistema de entrada (`evdev`, `libinput`).  

### 7.  ¿Qué hay en el directorio /dev? ¿Qué tipos de archivo encontramos en esa ubicación? 
El directorio `/dev` en GNU/Linux contiene archivos especiales que representan dispositivos del sistema. Es una interfaz entre el usuario y el hardware, porque en Linux todo es un archivo, incluso los dispositivos físicos.  
Cuando un proceso desea interactuar con un dispositivo, lo hace leyendo o escribiendo en su archivo correspondiente en `/dev`.

**<u>Tipos de archivos que encontramos en `/dev`:</u>**  

**Archivos de dispositivo de carácter (c)**:  
Usados para dispositivos que se acceden como un flujo de bytes.  
**Ejemplos:** `/dev/tty`, `/dev/console`.  

**Archivos de dispositivo de bloque (b)**:  
Usados para dispositivos que manejan datos en bloques de bytes.  
**Ejemplos:** discos rígidos `/dev/sda`, memorias USB, particiones `/dev/sda1`.  

**Enlaces simbólicos**:  
Algunos dispositivos tienen alias para facilitar su identificación.  
**Ejemplo:** /dev/cdrom puede ser un enlace a /dev/sr0.  

**Dispositivos virtuales o pseudo-dispositivos**:  
No representan hardware real, sino funciones útiles del sistema.  
**Ejemplos:**  
- `/dev/null`: "agujero negro" donde se descartan datos.
- `/dev/zero`: genera una secuencia infinita de ceros.
- `/dev/random` y `/dev/urandom`: generan números aleatorios.

**Dispositivos gestionados dinámicamente**:  
Sistemas como `udev` gestionan `/dev` de forma dinámica, **creando y eliminando dispositivos conforme se conectan o desconectan.**  

### 8.  ¿Para qué sirven el archivo /lib/modules/<version>/modules.dep utilizado por el comando modprobe? 
El archivo `/lib/modules/<versión>/modules.dep` lista las dependencias entre módulos del kernel.  
**Ejemplo:** `nombre_del_módulo.ko: dependencia1.ko dependencia2.ko`  
Es utilizado por modprobe para cargar automáticamente los módulos necesarios en el orden correcto.  
### 9.  ¿En qué momento/s se genera o actualiza un initramfs? 
**Durante la instalación del sistema operativo**:  
Cuando se instala una distribución GNU/Linux, el instalador **genera un initramfs inicial** para que el sistema pueda arrancar.  

**Cuando se instala o actualiza el kernel**:  
Al instalar un nuevo kernel (por ejemplo, mediante `apt`), se **genera un nuevo initramfs** correspondiente a esa versión de kernel.  

**Cuando se cambian drivers o configuraciones críticas**:  
Si se agregan drivers que son necesarios para arrancar (por ejemplo, drivers de disco, RAID, LVM, cifrado), se debe **regenerar el initramfs**.  

**Cuando se ejecuta manualmente el comando de regeneración**:  
`update-initramfs -u` (en distribuciones Debian/Ubuntu)  
### 10.  ¿Qué módulos y drivers deberá tener un initramfs mínimamente para cumplir su objetivo? 
**Módulos de drivers esenciales del kernel para que el kernel pueda detectar y montar el disco raíz**:

- **Drivers de almacenamiento**:  
    Para controlar el tipo de controlador SATA, NVMe, SCSI, etc.  
    **Ejemplos:** `ahci` (controlador SATA), `nvme`, `sd_mod` (disco SCSI), `ext4`, `xfs`. (si el sistema de archivos raíz usa esos formatos)  

- **Sistema de archivos**:  
    El módulo que permite interpretar el sistema de archivos raíz.  
    **Ejemplos:** `ext4`, `xfs`, `btrfs`.

- **Drivers de dispositivos de bloques**:  
    Para acceder correctamente a discos, particiones y bloques de datos.  

- **Controladores de bus**:  
    Como `pci`, `usb`, si el dispositivo raíz es accesible por estos buses.  

**Herramientas básicas de usuario (uspace)**:
- Shell mínima (`busybox`, por ejemplo)
- Scripts de arranque (`init` del initramfs)
- Utilidades como `mount`, `ls`, `udevadm`, etc.  

**Archivos de configuración**:   
- `init`: script principal que ejecuta el montaje y pasa el control al sistema raíz.  
- Hooks o scripts para detectar dispositivos, montar, iniciar LVM/RAID, desbloquear cifrado, etc.  

## Módulos y Drivers Práctica  







 
 
 


